# Phase 7: スライドピン留めフィードバック機能（LLM位置推定版）

## 概要

AIレビュー結果に含まれる位置情報（矩形・座標）を元に、Google Slides 上へ自動でピンとハイライトを重ね合わせる。ユーザーはスライド本体を編集せずに、指摘箇所を空間的に把握できる。

## 目的

- フィードバックとスライド上の対象要素の関連を即座に理解できるようにする
- 手作業でのピン配置を不要にし、レビュー完了から共有までのリードタイムを短縮
- サイドパネルとスライドの表示を同期させ、操作コンテキストの分断を防ぐ

## ユースケース

### ユースケース1: LLM出力を受け取って自動でピンを描画

**前提条件**
- Gemini が各指摘に対して `slidePage` と `rect`（相対座標 0〜1）を返す
- 拡張機能がレビュー処理完了後に JSON 形式の結果を受け取る

**フロー**
1. `handleRunCheck()` が Gemini へレビューを依頼
2. 応答のテキスト内、もしくは JSON ブロックを抽出し `feedbackItems` を構築
3. `anchors` 情報（対象スライド・矩形）から `pinsBySlide` を再生成
4. 現在のスライド上にピンと矩形ハイライトをオーバーレイ表示

**期待結果**
- 手動操作なしでピンが表示される
- サイドパネルには「📍 n箇所ハイライト中」のバッジが表示される

### ユースケース2: 指摘リストから該当スライドへジャンプ

**前提条件**
- サイドパネルに AI 指摘が並び、各行に表示ボタン（📍 スライドで表示）がある

**フロー**
1. ユーザーがリスト内の「📍 スライドで表示」をクリック
2. 拡張機能が該当スライドをフィルムストリップ上で選択
3. ページが切り替わり、ピンと矩形がフェードイン
4. 対応するリスト行がハイライトされる

**期待結果**
- サイドパネルとスライドの表示が同期
- 該当箇所が半透明の矩形として強調され、ピンのツールチップで要約を確認できる

### ユースケース3: スライド遷移時に表示対象を切り替え

**前提条件**
- 複数スライドにピンが存在し、定期的にスライド遷移を監視している

**フロー**
1. ユーザーが矢印キー等でスライドを切り替える
2. `MutationObserver` / `setInterval` によるウォッチで現在のスライドインデックスを検出
3. 現在ページに対応するピンだけを描画し、それ以外をクリア
4. ハイライト表示中だったピンの固定表示を解除

**期待結果**
- 表示が瞬時に更新され、ページ外のピンは表示されない
- バッジは全ピン数を示し続けるが、矩形は当該ページ分のみ描画される

## 機能仕様

### 1. LLM出力フォーマット

Gemini には JSON 形式での応答を促し、各指摘を以下の構造へ正規化する。`rect` はスライド内部の相対比率（0〜1）。

```json
{
  "feedbackItems": [
    {
      "id": "feedback-uuid",
      "title": "タイトル",
      "summary": "要約",
      "anchors": [
        {
          "slidePage": 2,
          "rect": { "x": 0.54, "y": 0.32, "width": 0.28, "height": 0.36 },
          "confidence": 0.82
        }
      ]
    }
  ]
}
```

### 2. データ正規化と状態構築

- `normalizeAnchor()` で `rect` を 0〜1 にクランプし、中心座標を算出
- `regeneratePinsFromFeedback()` が `anchors` から `pinsBySlide` を再構築
    - `pinId` は `crypto.randomUUID()` ベースで生成
    - `anchorIndex` による昇順ソートでピン番号を安定化
- `pinsBySlide` は `{ [slidePage]: Array<Pin> }` 形式で `state` に保持
- 将来的な永続化（`chrome.storage.local`）は別タスクとして拡張できるように余地を残す

### 3. 描画フロー

```
┌────────────────────────┐
│ Gemini応答(JSON)       │
└──────────┬─────────────┘
           │ parseFeedbackItems()
           ▼
┌────────────────────────┐
│ regeneratePinsFromFeedback │
│ ・pinsBySlide再生成        │
│ ・バッジ更新               │
└──────────┬─────────────┘
           │
           ▼
┌────────────────────────┐
│ renderPinsForCurrentSlide │
│ ・矩形(target div)描画     │
│ ・ピンボタン生成           │
│ ・ツールチップ紐付け       │
└──────────┬─────────────┘
           │
           ▼
┌────────────────────────┐
│ setOpenPin()            │
│ ・対象ピン強調           │
│ ・サイドパネル行ハイライト│
└────────────────────────┘
```

### 4. スライド監視とナビゲーション

- `startPinSlideWatcher()` が ~800ms 間隔でアクティブスライドをチェック
- スライド遷移検出時に `renderPinsForCurrentSlide()` を呼び、不要な DOM をクリア
- サイドパネルからの操作では `navigateToSlide(slidePage)` がフィルムストリップをクリックしてページを切り替える

### 5. エラーハンドリング

- アンカーが欠落している指摘は「位置情報なし」としてリスト表示（ボタンは無効化）
- 座標が取得できない/矩形サイズがゼロの場合はピン生成をスキップし、`console.warn` で調査ログを残す
- Gemini 応答が JSON でない場合はフォールバックとしてテキストのみ表示（既存の `status` 表示で通知）

## UI設計

### 1. サイドパネル

- `feedback-section` に AI 指摘のリストを表示
- 各指摘行では対象スライドを `Slide 2` のように表記
- 「📍 スライドで表示」ボタンでピンにフォーカス（複数アンカーの場合は `📍 n箇所を表示`）
- 位置情報が無い場合はボタンを無効化し、「位置情報なし」と表示
- ヘッダー右側のバッジは以下を切り替え
    - ピン留めモード中（将来の手動操作用）: `ピン留め中: <タイトル>`
    - 自動ハイライト数: `📍 n箇所ハイライト中`

### 2. スライドオーバーレイ

- `#gemini-pin-overlay`
    - `__targets`: アンカー矩形を半透明で描画（`border-radius: 12px`）
    - `__pins`: ピンボタン（📍番号）とツールチップ
- ピンをクリックするとツールチップが固定表示され、再クリックで閉じる
- ツールチップにはタイトル・要約を表示し、背景はダークテーマに準拠

### 3. ハイライト挙動

- サイドパネルで対象行がハイライトされ、スクロールも自動
- ピンを開いた際は対応する矩形に `is-open` クラスを付与し、透過度を上げる
- レビュー直後は最初のアンカーに合わせて自動的に該当スライドへ移動し、該当ピンを開く
- スライド遷移時は固定表示状態を解除し、矩形・ツールチップを再描画

### 4. モバイル/縮小表示への配慮

- 座標は相対値で保持するためズーム・ウィンドウサイズが変わっても位置ズレしない
- 矩形やピンは `pointer-events: none` のレイヤーと `pointer-events: auto` のボタンを分け、操作性を確保

## 開発メモ・今後の拡張

- **プロンプト指示**: Gemini へ渡す最終プロンプト末尾に JSON 出力仕様を強制し、`rect` を 0〜1 の相対座標で返すよう明示。不要時は既存の仕様マーカーで二重挿入を避ける。
- **JSONパース**: 現状はモックデータで検証。Gemini 応答からの JSON 抽出ユーティリティを実装予定（例: Markdown コードブロックを検出）
- **永続化**: `pins:${presentationId}` をキーに `chrome.storage.local` へ保存すれば、再訪時もピン情報を復元可能
- **複数アンカーへの対応**: 将来的には anchor ごとに独立したボタンを用意し、サイドパネル側でもアンカー単位での切り替え UI を検討
- **手動微調整**: LLM 座標の誤差を補正できるよう、ピンのドラッグ移動や再配置モードをオプションで復活させる計画
- **共同作業**: チーム共有を想定する場合は Firestore 等への同期と競合解決ルールの策定が必要
